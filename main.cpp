#include <Windows.h>
#include "detours/src/detours.h"
#include "config.h"
#include "module.h"
#include "sv.h"
#include <vector>
#include <string>
#include <list>
#include "md5.h"

extern clc_func_t *sv_clcfuncs;
extern client_t **phost_client;

static clc_func_t orig_clcfuncs[] =
{
	{ clc_bad, "clc_bad", NULL },   // 0
	{ clc_nop, "clc_nop", NULL },   // 1
	{ clc_move, "clc_move", NULL }, // 2
	{ clc_stringcmd, "clc_stringcmd", NULL }, // 3
	{ clc_delta, "clc_delta", NULL }, // 4
	{ clc_resourcelist, "clc_resourcelist", NULL }, // 5
	{ clc_tmove, "clc_tmove", NULL }, // 6
	{ clc_fileconsistency, "clc_fileconsistency", NULL }, // 7
	{ clc_voicedata, "clc_voicedata", NULL }, // 8
	{ clc_hltv, "clc_hltv", NULL }, // 9
	{ clc_cvarvalue, "clc_cvarvalue", NULL }, // 10
	{ clc_cvarvalue2, "clc_cvarvalue", NULL }, // 11
	{ (unsigned char)-1, "End of List", NULL }
};

extern fnNetchan_OutOfBandPrint Netchan_OutOfBandPrint;
extern fnSV_ConnectClient g_pfnSV_ConnectClient;
const char *g_pCurrentFunction;
extern netadr_t *net_from;
extern int *pmsg_readcount;
extern sizebuf_t *net_message;

extern short   (*BigShort) (short l);
extern short   (*LittleShort) (short l);
extern int     (*BigLong) (int l);
extern int     (*LittleLong) (int l);
extern float   (*BigFloat) (float l);
extern float   (*LittleFloat) (float l);
extern fnSV_DropClient SV_DropClient;
extern fnSV_ClientPrintf SV_ClientPrintf;
extern fnNetchan_Validate g_pfnNetchan_Validate;
extern fnNET_GetLong g_pfnNET_GetLong;

int g_maxplayers;

class CPlayerDownloadFile
{
public:
	CPlayerDownloadFile(void);
	~CPlayerDownloadFile(void);

	void clear(int player_slot);
	bool isAlreadyDownload(const char *filename);
	void addDownloadFile(const char *filename);
public:
	int m_PlayerSlot;
	bool isDisableDownload;
	std::vector<std::string> m_files;
};

std::vector<CPlayerDownloadFile> g_player_download_files;
std::list<std::string> g_precache_files;
extern cvar_t *sv_allow_dlfile;
extern cvar_t *sv_kick_dlfile;

//
// reading functions
//
int             msg_readcount;
qboolean        msg_badread;

void MSG_BeginReading (void)
{
	msg_readcount = *pmsg_readcount;
	msg_badread = false;
}

// returns -1 and sets msg_badread if no more characters are available
int MSG_ReadChar (void)
{
	int     c;
	
	if (msg_readcount+1 > net_message->cursize)
	{
		msg_badread = true;
		return -1;
	}
		
	c = (signed char)net_message->data[msg_readcount];
	msg_readcount++;
	
	return c;
}

int MSG_ReadByte (void)
{
	int     c;
	
	if (msg_readcount+1 > net_message->cursize)
	{
		msg_badread = true;
		return -1;
	}
		
	c = (unsigned char)net_message->data[msg_readcount];
	msg_readcount++;
	
	return c;
}

int MSG_ReadShort (void)
{
	int     c;
	
	if (msg_readcount+2 > net_message->cursize)
	{
		msg_badread = true;
		return -1;
	}
		
	c = (short)(net_message->data[msg_readcount]
	+ (net_message->data[msg_readcount+1]<<8));
	
	msg_readcount += 2;
	
	return c;
}

int MSG_ReadWord (void)
{
	int     c;
	
	if (msg_readcount+2 > net_message->cursize)
	{
		msg_badread = true;
		return -1;
	}
		
	c = (unsigned short)(net_message->data[msg_readcount]
	+ (net_message->data[msg_readcount+1]<<8));
	
	msg_readcount += 2;
	
	return c;
}

int MSG_ReadLong (void)
{
	int     c;
	
	if (msg_readcount+4 > net_message->cursize)
	{
		msg_badread = true;
		return -1;
	}
		
	c = net_message->data[msg_readcount]
	+ (net_message->data[msg_readcount+1]<<8)
	+ (net_message->data[msg_readcount+2]<<16)
	+ (net_message->data[msg_readcount+3]<<24);
	
	msg_readcount += 4;
	
	return c;
}

float MSG_ReadFloat (void)
{
	union
	{
		byte    b[4];
		float   f;
		int     l;
	} dat;
	
	dat.b[0] =      net_message->data[msg_readcount];
	dat.b[1] =      net_message->data[msg_readcount+1];
	dat.b[2] =      net_message->data[msg_readcount+2];
	dat.b[3] =      net_message->data[msg_readcount+3];
	msg_readcount += 4;
	
	dat.l = LittleLong (dat.l);

	return dat.f;   
}

char *MSG_ReadString (void)
{
	static char     string[8192];
	int             l,c;
	
	l = 0;
	do
	{
		c = MSG_ReadChar ();
		if (c == -1 || c == 0)
			break;
		string[l] = c;
		l++;
	} while (l < sizeof(string)-1);
	
	string[l] = 0;
	
	return string;
}

char *MSG_ReadStringLine (void)
{
	static char     string[8192];
	int             l,c;
	
	l = 0;
	do
	{
		c = MSG_ReadChar ();
		if (c == -1 || c == 0 || c == '\n')
			break;
		string[l] = c;
		l++;
	} while (l < sizeof(string)-1);
	
	string[l] = 0;
	
	return string;
}

int MSG_ReadBuf(int iSize, void *pbuf)
{
	if (msg_readcount + iSize > net_message->cursize)
	{
		msg_badread = true;
		return -1;
	}

	memcpy(pbuf, &net_message->data[msg_readcount], iSize);
	msg_readcount += iSize;
	return 1;
}

float MSG_ReadAngle (void)
{
	return MSG_ReadChar() * (360.0/256);
}

float MSG_ReadHiresAngle (void)
{
	return MSG_ReadShort() * (360.0/65536);
}

client_t *host_client;
void SV_ParseMove(client_t *pSenderClient)
{
	g_pCurrentFunction = __FUNCTION__;
	host_client = pSenderClient;

	orig_clcfuncs[clc_move].pfnParse(pSenderClient);

	host_client = NULL;
	g_pCurrentFunction = NULL;
}

void SV_ParseStringCommand(client_t *pSenderClient)
{
	g_pCurrentFunction = __FUNCTION__;
	host_client = pSenderClient;

	orig_clcfuncs[clc_stringcmd].pfnParse(pSenderClient);

	host_client = NULL;
	g_pCurrentFunction = NULL;
}

void SV_ParseDelta(client_t *pSenderClient)
{
	g_pCurrentFunction = __FUNCTION__;
	host_client = pSenderClient;

	orig_clcfuncs[clc_delta].pfnParse(pSenderClient);

	host_client = NULL;
	g_pCurrentFunction = NULL;
}

void SV_ParseResourceList(client_t *pSenderClient)
{
	int total;
	g_pCurrentFunction = __FUNCTION__;
	host_client = pSenderClient;


	MSG_BeginReading();
	total = MSG_ReadShort();

	if(total < 0 || total > 1024)
	{
		SV_ClientPrintf("Invalid ResourceList data\n");
		SV_DropClient(pSenderClient, false, "Invalid ResourceList data\n");
		return;
	}

	for ( int i = 0; i < total; i++ )
	{
		unsigned char md5[16];
		char *filename = MSG_ReadString();
		int type = MSG_ReadByte();
		int index = MSG_ReadShort();
		unsigned int size = (unsigned int)MSG_ReadLong();
		int flags = MSG_ReadByte();

		if ( flags & RES_CUSTOM )
			MSG_ReadBuf( 16, md5);

		if ( type > t_world || size > 1024 * 1024 * 1024 )
		{
			SV_ClientPrintf("Invalid resource type or size.\n");
			SV_DropClient(pSenderClient, false, "Invalid resource type or size.\n");
			return;
		}
	}

	orig_clcfuncs[clc_resourcelist].pfnParse(pSenderClient);

	host_client = NULL;
	g_pCurrentFunction = NULL;
}

void SV_ParseConsistencyResponse(client_t *pSenderClient)
{
	int length;
	g_pCurrentFunction = __FUNCTION__;
	host_client = pSenderClient;

	MSG_BeginReading();
	length = MSG_ReadShort();

	if(length < 0 && length > 0x1000)
	{
		SV_ClientPrintf("Wrong Consistency length.\n");
		SV_DropClient(pSenderClient, false, "Wrong Consistency length.\n");
		return;
	}

	orig_clcfuncs[clc_fileconsistency].pfnParse(pSenderClient);

	host_client = NULL;
	g_pCurrentFunction = NULL;
}

void SV_ParseVoiceData(client_t *pSenderClient)
{
	MSG_BeginReading();
	unsigned int nDataLength = MSG_ReadShort();

	if( nDataLength > 0x1000) 
	{
		SV_ClientPrintf("Invalid voice data length.\n");
		SV_DropClient(pSenderClient, false, "Invalid voice data length.\n");
		return;
	}

	g_pCurrentFunction = __FUNCTION__;
	host_client = pSenderClient;

	orig_clcfuncs[clc_voicedata].pfnParse(pSenderClient);

	host_client = NULL;
	g_pCurrentFunction = NULL;
}

void SV_ParseCvarValue(client_t *pSenderClient)
{
	g_pCurrentFunction = __FUNCTION__;
	host_client = pSenderClient;

	orig_clcfuncs[clc_cvarvalue].pfnParse(pSenderClient);

	host_client = NULL;
	g_pCurrentFunction = NULL;
}

void SV_ParseCvarValue2(client_t *pSenderClient)
{
	g_pCurrentFunction = __FUNCTION__;
	host_client = pSenderClient;

	orig_clcfuncs[clc_cvarvalue2].pfnParse(pSenderClient);

	host_client = NULL;
	g_pCurrentFunction = NULL;
}


void SV_RejectConnection(netadr_t *adr, char *fmt, ... )
{
	va_list		argptr;
	char	text[1024];

	va_start (argptr, fmt);
	_vsnprintf ( text, sizeof( text ), fmt, argptr);
	va_end (argptr);

	Netchan_OutOfBandPrint(NS_SERVER, *adr, "%c%c%c%c%c%s%c",255,255,255,255,S2C_CONNREJECT,text,0 );
}


#define MAX_KV_LEN 127
bool Info_IsValid ( const char *s )
{
	char	key[128];
	char	value[128];
	char	*o;
//	int		l;

	if (*s == '\\')
		s++;
	while (*s)
	{
		int nCount;

		nCount = 0;
		o = key;
		while (nCount < MAX_KV_LEN && *s && *s != '\\')
		{
			*o++ = *s++;
			nCount++;
		}
		*o = 0;

		if (!*s)
			return false;

		nCount = 0;
		o = value;
		s++;
		while (nCount < MAX_KV_LEN && *s && *s != '\\')
		{
			*o++ = *s++;
			nCount++;
		}
		*o = 0;

		if ( strlen( value ) == 0 )
			return false;

		if (*s)
			s++;
	}

	return true;
}

const char *Info_ValueForKey ( const char *s, const char *key )
{
	char	pkey[128];
	static	char value[4][128];	// use two buffers so compares
								// work without stomping on each other
	static	int	valueindex;
	char	*o;

	valueindex = (valueindex + 1) % 4;
	if (*s == '\\')
		s++;
	while (1)
	{
		int nCount;

		nCount = 0;
		o = pkey;
		while (nCount < MAX_KV_LEN && *s != '\\')
		{
			if (!*s)
				return "";
			*o++ = *s++;
			nCount++;
		}
		*o = 0;
		s++;

		nCount = 0;
		o = value[valueindex];

		while (nCount < MAX_KV_LEN && *s != '\\' && *s)
		{
			if (!*s)
				return "";
			*o++ = *s++;
			nCount++;
		}
		*o = 0;

		if (!strcmp (key, pkey) )
			return value[valueindex];

		if (!*s)
			return "";
		s++;
	}
}


void Info_RemoveKey ( char *s, const char *key )
{
	char	*start;
	char	pkey[128];
	char	value[128];
	char	*o;

	int cmpsize = strlen( key );

	if ( cmpsize > MAX_KV_LEN )
		cmpsize = MAX_KV_LEN;

	if (strstr (key, "\\"))
	{
		ALERT(at_console ,"Can't use a key with a \\\n");
		return;
	}

	while (1)
	{
		int nCount;

		start = s;
		if (*s == '\\')
			s++;
		nCount = 0;
		o = pkey;
		while (nCount < MAX_KV_LEN && *s != '\\')
		{
			if (!*s)
				return;
			*o++ = *s++;
			nCount++;
		}
		*o = 0;
		s++;

		nCount = 0;
		o = value;
		while (nCount < MAX_KV_LEN && *s != '\\' && *s)
		{
			if (!*s)
				return;
			*o++ = *s++;
			nCount++;
		}
		*o = 0;

		if (!strncmp (key, pkey, cmpsize) )
		{
			strcpy (start, s);	// remove this part
			return;
		}

		if (!*s)
			return;
	}

}


qboolean Info_IsKeyImportant( const char *key )
{
	if ( key[0] == '*' )
		return true;
	if ( !strcmp( key, "name" ) )
		return true;
	if ( !strcmp( key, "model" ) )
		return true;
	if ( !strcmp( key, "rate" ) )
		return true;
	if ( !strcmp( key, "topcolor" ) )
		return true;
	if ( !strcmp( key, "bottomcolor" ) )
		return true;
	if ( !strcmp( key, "cl_updaterate" ) )
		return true;
	if ( !strcmp( key, "cl_lw" ) )
		return true;
	if ( !strcmp( key, "cl_lc" ) )
		return true;
	if ( !strcmp( key, "*tracker" ) )
		return true;
	if ( !strcmp( key, "*hltv" ) )
		return true;
	if ( !strcmp( key, "*sid" ) )
		return true;

	return false;
}

char *Info_FindLargestKey( char *s )
{
	char	key[128];
	char	value[128];
	char	*o;
	int		l;
	static char largest_key[128];
	int     largest_size = 0;

	*largest_key = 0;

	if (*s == '\\')
		s++;
	while (*s)
	{
		int nCount;
		int size = 0;

		nCount = 0;
		o = key;
		while (nCount < MAX_KV_LEN && *s && *s != '\\')
		{
			*o++ = *s++;
			nCount++;
		}

		l = o - key;
		*o = 0;
		size = strlen( key );

		if (!*s)
		{
			return largest_key;
		}

		nCount = 0;
		o = value;
		s++;
		while (nCount < MAX_KV_LEN && *s && *s != '\\')
		{
			*o++ = *s++;
			nCount++;
		}
		*o = 0;

		if (*s)
			s++;

		size += strlen( value );

		if ( (size > largest_size) && !Info_IsKeyImportant(key) )
		{
			largest_size = size;
			strncpy( largest_key, key, sizeof( largest_key ) - 1 );
			largest_key[ sizeof( largest_key ) - 1 ] = 0;
		}
	}

	return largest_key;
}


void Info_SetValueForStarKey ( char *s, const char *key, const char *value, int maxsize )
{
	char	newVal[1024], *v;
	int		c;
//	char *largekey;

	if (strstr (key, "\\") || strstr (value, "\\") )
	{
		ALERT(at_console ,"Can't use keys or values with a \\\n");
		return;
	}

	if (strstr (key, "..") || strstr (value, "..") )
	{
		return;
	}

	if (strstr (key, "\"") || strstr (value, "\"") )
	{
		ALERT(at_console ,"Can't use keys or values with a \"\n");
		return;
	}

	if (strlen(key) > MAX_KV_LEN || strlen(value) > MAX_KV_LEN)
	{
		ALERT(at_console ,"Keys and values must be < %i characters.\n", MAX_KV_LEN + 1 );
		return;
	}

	Info_RemoveKey (s, key);
	if (!value || !strlen(value))
		return;

	_snprintf (newVal, sizeof( newVal ), "\\%s\\%s", key, value);

 	if ( (int)(strlen(newVal) + strlen(s)) >= maxsize)
	{
		// no more room in buffer to add key/value
		if ( Info_IsKeyImportant( key ) )
		{
			// keep removing the largest key/values until we have room
			char *largekey;
			do {
				largekey = Info_FindLargestKey( s );
				Info_RemoveKey( s, largekey );
			} while ( ((int)(strlen(newVal) + strlen(s)) >= maxsize) && *largekey != 0 );

			if ( largekey[0] == 0 )
			{
				// no room to add setting
				ALERT(at_console ,"Info string length exceeded\n");
				return;
			}
		}
		else
		{
			// no room to add setting
			ALERT(at_console ,"Info string length exceeded\n");
			return;
		}
	}

	// only copy ascii values
	s += strlen(s);
	v = newVal;
	while (*v)
	{
		c = (unsigned char)*v++;
		// client only allows highbits on name
		if (stricmp(key, "name") != 0) {
			c &= 127;
			if (c < 32 || c > 127)
				continue;
			// auto lowercase team
			if (stricmp(key, "team") == 0)
				c = tolower(c);
		}
		if (c > 13)
			*s++ = c;
	}
	*s = 0;
}

void Info_SetValueForKey (char *s, const char *key, const char *value, int maxsize)
{
	if (key[0] == '*')
	{
		ALERT(at_console ,"Can't set * keys\n");
		return;
	}

	Info_SetValueForStarKey (s, key, value, maxsize);
}


void SV_ConnectClient ()
{
	netadr_t adr = *net_from;
	char *s;
	if (g_engfuncs.pfnCmd_Argc() < 5)
	{
		SV_RejectConnection( &adr, "Insufficient connection info\n");
		return;
	}

	s = (char *)g_engfuncs.pfnCmd_Argv(3);

	if ( strlen( s ) > MAX_INFO_STRING || !Info_IsValid( s ) )
	{
		SV_RejectConnection( &adr, "Invalid userinfo in connect command\n" );
		return;
	}
	{
		size_t i;

		i = strlen( s );

		if ( i < 4 || strstr( s, "\\\\" ) || strstr( s, "\\\"" ) )
		{
			SV_RejectConnection( &adr, "Unknown HLTV client type.\n" );
			return;
		}
	}

	s = (char *)g_engfuncs.pfnCmd_Argv(4);

	if ( strlen( s ) > MAX_INFO_STRING || !Info_IsValid( s ) )
	{
		SV_RejectConnection( &adr, "Invalid userinfo in connect command\n" );
		return;
	}

	{
		size_t i;

		i = strlen( s );

		if ( i < 4 || strstr( s, "\\\\" ) || strstr( s, "\\\"" ) )
		{
			SV_RejectConnection( &adr, "Unknown HLTV client type.\n" );
			return;
		}

		// name for C code
		const char *val = Info_ValueForKey (s, "name");

		if (!val || !val[0] || strstr(val, "..")) {
			Info_SetValueForKey (s, "name", "unamed", MAX_INFO_STRING);
		}
	}

	Info_SetValueForKey (s, "cl_dlmax", "1024", MAX_INFO_STRING);

	*phost_client = NULL;
	g_pfnSV_ConnectClient();

	if(*phost_client)
	{
		host_client = *phost_client;
		netchan_t *chan = (netchan_t *)((ULONG_PTR)host_client + 0x20);

		g_player_download_files[chan->player_slot].clear(chan->player_slot);
		g_player_download_files[chan->player_slot].isDisableDownload=true;
	}
}

extern "C" void Netchan_Process_Fix();

void patch_clc_functions()
{
	for(int i =0; i <= CLC_LASTMSG; i++)
	{
		orig_clcfuncs[i].pfnParse = sv_clcfuncs[i].pfnParse;
	}

	sv_clcfuncs[clc_move].pfnParse = SV_ParseMove;
	sv_clcfuncs[clc_stringcmd].pfnParse = SV_ParseStringCommand;
	sv_clcfuncs[clc_delta].pfnParse = SV_ParseDelta;
	sv_clcfuncs[clc_resourcelist].pfnParse = SV_ParseResourceList;
	sv_clcfuncs[clc_fileconsistency].pfnParse = SV_ParseConsistencyResponse;
	sv_clcfuncs[clc_voicedata].pfnParse = SV_ParseVoiceData;
	// sv_clcfuncs[clc_hltv].pfnParse = SV_IgnoreHLTV;
	sv_clcfuncs[clc_cvarvalue].pfnParse = SV_ParseCvarValue;
	sv_clcfuncs[clc_cvarvalue2].pfnParse = SV_ParseCvarValue2;
}

void patch_SV_ConnectClient(void)
{
	DetourTransactionBegin();
	DetourAttach((PVOID*)&g_pfnSV_ConnectClient, SV_ConnectClient);
	DetourTransactionCommit();
}

extern void (*SZ_Write) (sizebuf_t *buf, void *data, int length);
extern void *patch_Netchan_Process_SZ_Write;

void Netchan_Process_At_SZ_Write (sizebuf_t *buf, void *data, int length)
{
	unsigned char *pbuf = (unsigned char *)data;
	if(buf->maxsize < length)
	{
		buf->flags |= FSB_OVERFLOWED;
		return;
	}

	if((net_message->data - pbuf) > net_message->maxsize)
		return;

	return SZ_Write(buf, data, length);
}


void Patch_Netchan_Process_SZ_Write()
{
	DWORD op;

	int offset = ((unsigned char *)Netchan_Process_At_SZ_Write - (unsigned char *)patch_Netchan_Process_SZ_Write - 0x5);

	VirtualProtect(patch_Netchan_Process_SZ_Write, 0x5, PAGE_EXECUTE_READWRITE, &op);
	*(int *)&(((unsigned char *)patch_Netchan_Process_SZ_Write)[1]) = offset;
	VirtualProtect(patch_Netchan_Process_SZ_Write, 0x5, op, &op);
}


char const* Q_stristr( char const* pStr, char const* pSearch )
{
	char const* pLetter;

	if (!pStr || !pSearch) 
		return 0;

	pLetter = pStr;

	// Check the entire string
	while (*pLetter != 0)
	{
		// Skip over non-matches
		if (tolower(*pLetter) == tolower(*pSearch))
		{
			// Check for match
			char const* pMatch = pLetter + 1;
			char const* pTest = pSearch + 1;
			while (*pTest != 0)
			{
				// We've run off the end; don't bother.
				if (*pMatch == 0)
					return 0;

				if (tolower(*pMatch) != tolower(*pTest))
					break;

				++pMatch;
				++pTest;
			}

			// Found a match!
			if (*pTest == 0)
				return pLetter;
		}

		++pLetter;
	}

	return 0;
}

qboolean IsSafeFileToDownload( const char *filename )
{
	char *first, *last;
	char lwrfilename[256];

	if ( !filename )
		return false;

	if ( !strncmp( filename, "!MD5", 4 ) )
		return true;

	strncpy( lwrfilename, filename, sizeof( lwrfilename ) -1 );
	lwrfilename[sizeof( lwrfilename ) -1] = 0;

	strlwr( lwrfilename );

	if ( strstr( lwrfilename, "\\" ) || strstr( lwrfilename, ":" ) || 
		strstr( lwrfilename, ".." ) || strstr( lwrfilename, "~" ) )
	{
		return false;
	}

	if ( lwrfilename[0] == '/' )
		return false;

	first = strchr( lwrfilename, '.' );
	last = strrchr( lwrfilename, '.' );

	if ( first == NULL || last == NULL )
		return false;

	if ( first != last )
		return false;

	if ( strlen(first) != 4 )
		return false;

	if ( Q_stristr( lwrfilename, ".cfg" ) || Q_stristr( lwrfilename, ".lst" ) || 
		Q_stristr( lwrfilename, ".exe" ) || Q_stristr( lwrfilename, ".vbs" ) || 
		Q_stristr( lwrfilename, ".com" ) || Q_stristr( lwrfilename, ".bat" ) || 
		Q_stristr( lwrfilename, ".dll" ) || Q_stristr( lwrfilename, ".ini" ) || 
		Q_stristr( lwrfilename, ".log" ) || Q_stristr( lwrfilename, "halflife.wad" ) || 
		Q_stristr( lwrfilename, "pak0.pak" ) || Q_stristr( lwrfilename, "xeno.wad" ) || 
		Q_stristr( lwrfilename, ".so" ) || Q_stristr( lwrfilename, ".dylib" ) || 
		Q_stristr( lwrfilename, ".sys" ) )
	{
		return false;
	}

	return true;
}

xcommand_t g_pfnSV_BeginFileDownload_f;

char *NET_AdrToString(netadr_t a)
{
	static char s[64];

	memset(s, 0, 64);

	if (a.type == NA_LOOPBACK)
		_snprintf(s, sizeof(s)-1, "loopback");
	else if (a.type == NA_IP)
		_snprintf(s, sizeof(s)-1, "%i.%i.%i.%i:%i", a.ip[0], a.ip[1], a.ip[2], a.ip[3], ntohs(a.port));
	else
		_snprintf(s, sizeof(s)-1, "%02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x:%i", a.ipx[0], a.ipx[1], a.ipx[2], a.ipx[3], a.ipx[4], a.ipx[5], a.ipx[6], a.ipx[7], a.ipx[8], a.ipx[9], ntohs(a.port));

	s[sizeof(s)-1]=0;
	return s;
}


CPlayerDownloadFile::CPlayerDownloadFile()
{
	m_PlayerSlot = 0;
	isDisableDownload = true;
}

CPlayerDownloadFile::~CPlayerDownloadFile(void)
{

}

void CPlayerDownloadFile::clear(int player_slot)
{
	m_PlayerSlot = player_slot;
	m_files.clear();
}

bool CPlayerDownloadFile::isAlreadyDownload(const char *filename)
{
	for(size_t i = 0; i < m_files.size();i++)
	{
		if(!_stricmp(m_files[i].c_str(), filename))
			return true;
	}

	return false;
}

void CPlayerDownloadFile::addDownloadFile(const char *filename)
{
	m_files.push_back(filename);
}


void SV_BeginFileDownload_f( void )
{
	char mapname[128];
	char *name;
	char *last;

	netchan_t *chan = (netchan_t *)((ULONG_PTR)host_client + 0x20);

	if(host_client == NULL)
	{
		g_pfnSV_BeginFileDownload_f();
		return;
	}

	if ( g_engfuncs.pfnCmd_Argc() < 2 )
		return;

	
	name = (char *)g_engfuncs.pfnCmd_Argv(1);

	if(!name[0])
		return;

	if(!strncmp(name, "!ModuleC.dll",12))
	{
		g_pfnSV_BeginFileDownload_f();
		return;
	}

	if(!IsSafeFileToDownload(name))
		return;
	
	if(sv_allow_dlfile->value == 0)
	{
		if(g_player_download_files[chan->player_slot].isDisableDownload)
		{
			if(sv_kick_dlfile->value != 0)
			{
				SV_ClientPrintf("Do not allow file downloads!\n");
				SV_DropClient(host_client, false, "Do not allow file downloads!\n");
			}
			
			return;
		}

		bool allow= false;

		last = strrchr( name, '.' );
		if( !_stricmp( last, ".bsp" ) )
		{
			_snprintf(mapname, 127, "maps/%s.bsp", STRING( gpGlobals->mapname ));
			mapname[127]=0;

			if(_stricmp(name, mapname))
			{
				if(sv_kick_dlfile->value != 0)
				{
					SV_ClientPrintf("Refuse to download the wrong map file!\n");
					SV_DropClient(host_client, false, "Refuse to download the wrong map file!\n");
				}
				return;
			}

			allow = true;
		}

		if(!allow)
		{
			for(auto pos = g_precache_files.begin(); pos != g_precache_files.end(); pos++)
			{
				if(!_stricmp(name, (*pos).c_str()))
				{
					allow=true;
					break;
				}
			}
		}

		if(!allow)
		{
			if(sv_kick_dlfile->value != 0)
			{
				SV_ClientPrintf("Refuse to download resources \"%s\" that are not precached.!\n",name);
				SV_DropClient(host_client, false, "Refuse to download resources \"%s\" that are not precached.!\n",name);
			}
			return;
		}
	}

	if(g_player_download_files[chan->player_slot].isAlreadyDownload(name))
	{	
		return;
	}

	g_player_download_files[chan->player_slot].addDownloadFile(name);
	g_pfnSV_BeginFileDownload_f();
}



void ServerActivate(edict_t *pEdictList, int edictCount, int clientMax)
{
	g_maxplayers = clientMax;

	g_player_download_files.clear();
	g_player_download_files.resize(clientMax + 0x1);

	RETURN_META(MRES_IGNORED);
}

void ServerDeactivate()
{
	for(size_t i = 0; i < g_player_download_files.size();i++)
	{
		g_player_download_files[i].m_files.clear();
		g_player_download_files[i].isDisableDownload = false;
	}


	g_precache_files.clear();

	RETURN_META(MRES_IGNORED);
}

BOOL ClientConnect(edict_t *pEntity, const char *pszName, const char *pszAddress, char szRejectReason[ 128 ])
{
	netchan_t *chan = (netchan_t *)((ULONG_PTR)host_client + 0x20);
	g_player_download_files[chan->player_slot].clear(chan->player_slot);
	g_player_download_files[chan->player_slot].isDisableDownload = false;

	RETURN_META_VALUE( MRES_IGNORED, TRUE );
}

VOID ClientPutInServer(edict_t *pEntity)
{
	netchan_t *chan = (netchan_t *)((ULONG_PTR)host_client + 0x20);
	g_player_download_files[chan->player_slot].clear(chan->player_slot);
	g_player_download_files[chan->player_slot].isDisableDownload = true;

	RETURN_META(MRES_IGNORED);
}

void ClientDisconnect(edict_t *pEntity)
{
	netchan_t *netchan = (netchan_t *)((ULONG_PTR)host_client + 0x20);

	RETURN_META( MRES_IGNORED );
}

extern cmd_function_t **cmd_functions;

cmd_function_t *Cmd_FindCmd(char *cmd_name)
{
	for (cmd_function_t *cmd = *cmd_functions; cmd; cmd = cmd->next)
	{
		if (!strcmp(cmd->name, cmd_name))
			return cmd;
	}

	return NULL;
}

cmd_function_t *Cmd_FindCmdPrev(char *cmd_name)
{
	cmd_function_t *cmd;

	for (cmd = *cmd_functions; cmd->next; cmd = cmd->next)
	{
		if (!strcmp(cmd_name, cmd->next->name))
			return cmd;
	}

	return NULL;
}

int Cmd_AddCommand(char *cmd_name, xcommand_t function)
{
	g_engfuncs.pfnAddServerCommand(cmd_name, function);
	return 1;
}

xcommand_t Cmd_HookCmd(char *cmd_name, xcommand_t newfuncs)
{
	cmd_function_t *cmd = Cmd_FindCmd(cmd_name);

	if (!cmd)
	{
		Cmd_AddCommand(cmd_name, newfuncs);
		return newfuncs;
	}

	xcommand_t result = cmd->function;
	cmd->function = newfuncs;
	return result;
}

#define MAX_CLIENTS 32
static float s_LastFullUpdate[MAX_CLIENTS + 1];

xcommand_t g_pfnSV_FullUpdate_f;
void SV_FullUpdate_f( void )
{
	float ltime;

	netchan_t *netchan = (netchan_t *)((ULONG_PTR)host_client + 0x20);

	int entIndex = netchan->player_slot;

	if ( s_LastFullUpdate[entIndex] > g_engfuncs.pfnTime()  )
		s_LastFullUpdate[entIndex] = 0;


	ltime = g_engfuncs.pfnTime() - s_LastFullUpdate[entIndex];

	if ( ltime < 0 )
		ltime = 0;

	if ( ltime < 0.45 && g_engfuncs.pfnTime()  > 0.45 )
	{
		return;
	}

	s_LastFullUpdate[entIndex] = ltime;

	g_pfnSV_FullUpdate_f();
}

int (*g_pfnPrecacheModel)(char *s);
int (*g_pfnPrecacheSound)(char *s);
int (*g_pfnPrecacheGeneric)(char *s);

void AddPrecache(char *s)
{
	bool found = false;
	for(auto pos = g_precache_files.begin(); pos != g_precache_files.end(); pos++)
	{
		if(!_stricmp(s, (*pos).c_str()))
		{
			found = true;
			break;
		}
	}

	if(!found)
	{
		g_precache_files.emplace_back(s);
	}
}

int PrecacheModel(char *s)
{
	int index = g_pfnPrecacheModel(s);
	if(index > 0)
	{
		AddPrecache(s);
	}
	return index;
}

int PrecacheSound(char *s)
{
	char name[MAX_PATH];
	int index = g_pfnPrecacheSound(s);
	if(index > 0)
	{
		_snprintf(name, MAX_PATH-1, "sound/%s", s);
		name[MAX_PATH-1] = 0;
		AddPrecache(name);
	}
	return index;
}

int PrecacheGeneric(char *s)
{
	int index = g_pfnPrecacheGeneric(s);

	if(index > 0)
	{
		AddPrecache(s);
	}

	return index;
}

#define MAKE_FRAGID(id,count)	( ( ( id & 0xffff ) << 16 ) | ( count & 0xffff ) )
#define FRAG_GETID(fragid)		( ( fragid >> 16 ) & 0xffff )
#define FRAG_GETCOUNT(fragid)	( fragid & 0xffff )

//
qboolean Netchan_Validate( struct netchan_s *chan, qboolean *frag_message, unsigned int *fragid, int *frag_offset, int *frag_length )
{
	int i;
	int buffer;
	int count;

	for ( i = 0; i < MAX_STREAMS; i++ )
	{
		if ( !frag_message[i] )
			continue;

		buffer = FRAG_GETID( fragid[i] );
		count = FRAG_GETCOUNT( fragid[i] );

		if ( buffer < 0 || buffer > 25000 )
			return false;

		if ( count < 0 || count > 25000 )
			return false;

		if ( frag_length[i] < 0 || frag_length[i] > 2048 )
			return false;

		if ( frag_offset[i] < 0 || frag_offset[i] > 16384 )
			return false;
	}

	return true;
}

void patch_Netchan_Validate(void)
{
	DetourTransactionBegin();
	DetourAttach((PVOID*)&g_pfnNetchan_Validate, Netchan_Validate);
	DetourTransactionCommit();
}



// Use this to pick apart the network stream, must be packed
#pragma pack(1)
typedef struct
{
	int		netID;
	int		sequenceNumber;
	byte	packetID;
} SPLITPACKET;
#pragma pack()

#define MAX_SPLITPACKET_SPLITS 5
#define MAX_MSGLEN 4010 
#define MAX_ROUTEABLE_PACKET		1400
#define SPLIT_SIZE (MAX_ROUTEABLE_PACKET - sizeof(SPLITPACKET))

#define MAX_SPLITPACKET_SPLITS 5

// Split long packets.  Anything over 1460 is failing on some routers
typedef struct
{
	int		currentSequence;
	int		splitCount;
	int		totalSize;
	char	buffer[ MAX_MSGLEN ];	// This has to be big enough to hold the largest message
} LONGPACKET;

LONGPACKET gNetSplit;



//-----------------------------------------------------------------------------
// Purpose: 
// Input  : *pData - 
//			size - 
//			*outSize - 
// Output : qboolean
//-----------------------------------------------------------------------------
qboolean NET_GetLong( byte *pData, int size, int *outSize )
{
	int				packetNumber, packetCount, sequenceNumber, offset;
	byte			packetID;
	SPLITPACKET		*pHeader;

	// Last sequence of packet
	static int gNetSplitFlags[ MAX_SPLITPACKET_SPLITS ] = { -1, -1, -1, -1, -1 };

	pHeader = ( SPLITPACKET * )pData;
	sequenceNumber	= pHeader->sequenceNumber;
	packetID		= pHeader->packetID;
	// High byte is packet number
	packetNumber	= ( packetID >> 4 );	
	// Low byte is number of total packets
	packetCount		= ( packetID & 0xf );	

	if ( packetNumber < 0 || packetNumber >= MAX_SPLITPACKET_SPLITS ||
		 packetCount < 0 || packetCount > MAX_SPLITPACKET_SPLITS )
	{
		return false;
	}

	// First packet in split series?
	if ( gNetSplit.currentSequence == -1 || 
		sequenceNumber != gNetSplit.currentSequence )
	{
		gNetSplit.currentSequence	= sequenceNumber;
		gNetSplit.splitCount		= packetCount;

	}

	size -= sizeof(SPLITPACKET);

	if ( gNetSplitFlags[ packetNumber ] != sequenceNumber )
	{
		// Last packet in sequence? set size
		if ( packetNumber == (packetCount-1) )
		{
			gNetSplit.totalSize = (packetCount-1) * SPLIT_SIZE + size;
		}

		gNetSplit.splitCount--;		// Count packet
		gNetSplitFlags[ packetNumber ] = sequenceNumber;


		// Overflow size?
		if ( packetNumber * SPLIT_SIZE + size > MAX_MSGLEN )
		{
			return false;
		}

		// Copy the incoming data to the appropriate place in the buffer
		offset = (packetNumber * SPLIT_SIZE);
		memcpy( gNetSplit.buffer + offset, pData + sizeof(SPLITPACKET), size );
	}
	else
	{
		// Con_Printf( "NET_GetLong:  Ignoring duplicated split packet %i of %i ( %i bytes )\n", packetNumber + 1, size );
	}

	// Have we received all of the pieces to the packet?
	if ( gNetSplit.splitCount <= 0 )
	{
		int i;

		for ( i = 0; i < packetCount; i++ )
		{
			if ( gNetSplitFlags[i] != gNetSplit.currentSequence )
			{
				// Con_Printf("Split packet without all %i parts, part %i had wrong sequence %i/%i\n", gNetSplit.currentSequence, i + 1, gNetSplitFlags[i], gNetSplit.currentSequence );
				return false;
			}
		}

		gNetSplit.currentSequence = -1;	// Clear packet
		if ( gNetSplit.totalSize > sizeof(gNetSplit.buffer) )
		{
			// Con_Printf("Split packet too large! %d bytes\n", gNetSplit.totalSize );
			return false;
		}

		memcpy( pData, gNetSplit.buffer, gNetSplit.totalSize );
		*outSize = gNetSplit.totalSize;
		return true;
	}

	return false;
}

void patch_NET_GetLong(void)
{
	DetourTransactionBegin();
	DetourAttach((PVOID*)&g_pfnNET_GetLong, NET_GetLong);
	DetourTransactionCommit();
}

void Patch_Commands(void)
{
	g_pfnSV_BeginFileDownload_f = Cmd_HookCmd("dlfile", SV_BeginFileDownload_f);
	g_pfnSV_FullUpdate_f = Cmd_HookCmd("fullupdate", SV_FullUpdate_f);

	g_pfnPrecacheModel = g_engfuncs.pfnPrecacheModel;
	g_pfnPrecacheSound = g_engfuncs.pfnPrecacheSound;
	g_pfnPrecacheGeneric = g_engfuncs.pfnPrecacheGeneric;

	DetourTransactionBegin();
	DetourAttach((PVOID *)&g_pfnPrecacheModel, PrecacheModel);
	DetourAttach((PVOID *)&g_pfnPrecacheSound, PrecacheSound);
	DetourAttach((PVOID *)&g_pfnPrecacheGeneric, PrecacheGeneric);
	DetourTransactionCommit();
}