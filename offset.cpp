#include "config.h"
#include "module.h"
#include <vector>
#include <ImageHlp.h>
#include "sv.h"

#pragma comment(lib, "ImageHlp.lib")


HMODULE g_hEngineDLL;

std::vector<PDWORD_PTR> g_vecReloc;
PIMAGE_SECTION_HEADER psech;
PIMAGE_NT_HEADERS pnth;
clc_func_t *sv_clcfuncs;
fnNetchan_OutOfBandPrint Netchan_OutOfBandPrint;
fnSV_ConnectClient g_pfnSV_ConnectClient;
netadr_t *net_from;
sizebuf_t *net_message;
int *pmsg_readcount;
fnSV_DropClient SV_DropClient;
fnSV_ClientPrintf SV_ClientPrintf;
fnNetchan_Validate g_pfnNetchan_Validate;
fnNET_GetLong g_pfnNET_GetLong;

bool data_compare( PUCHAR pData, PUCHAR pMask, const char* pszMask )
{
	for( ; *pszMask; ++pszMask, ++pData, ++pMask )
	{
		if( *pszMask == 'x' && *pData != *pMask )
		{
			return false;
		}
	}

	return ( *pszMask == NULL );
}

PVOID find_pattern(PVOID lpStartAddress, DWORD_PTR dwSize, const char* pSignature, const char* pMask)
{
	for (DWORD_PTR dwIndex = 0; dwIndex < dwSize; dwIndex++)
	{
		if (data_compare((PUCHAR)lpStartAddress + dwIndex, (PUCHAR)pSignature, pMask))
		{
			return ((PUCHAR)lpStartAddress + dwIndex);
		}
	}
	return NULL;
}

bool parse_reloc(void)
{
	g_hEngineDLL = GetModuleHandle(TEXT("swds.dll"));

	if( g_hEngineDLL == NULL )
		g_hEngineDLL = GetModuleHandle(TEXT("hw.dll"));

	if( g_hEngineDLL == NULL )
		g_hEngineDLL = GetModuleHandle(TEXT("sw.dll"));

	if( g_hEngineDLL == NULL )
		return false;


	pnth = ImageNtHeader(g_hEngineDLL);

	if( pnth == NULL )
		return false;

	psech = IMAGE_FIRST_SECTION(pnth);

	DWORD_PTR EndOfCode = psech[0].Misc.VirtualSize + psech[0].VirtualAddress + (DWORD_PTR)g_hEngineDLL;

	PIMAGE_DATA_DIRECTORY pdd = &pnth->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
	if(pdd->VirtualAddress != 0 && pdd->Size != 0)
	{
		DWORD TotalCountBytes = pdd->Size;
		DWORD SizeOfBlock;
		PUSHORT NextOffset;
		ULONG_PTR VA;
		PIMAGE_BASE_RELOCATION pbr = (PIMAGE_BASE_RELOCATION)(pdd->VirtualAddress + (ULONG_PTR)g_hEngineDLL);

		while( TotalCountBytes )
		{
			SizeOfBlock = pbr->SizeOfBlock;
			TotalCountBytes -= SizeOfBlock;
			SizeOfBlock -= sizeof( IMAGE_BASE_RELOCATION );
			SizeOfBlock /= sizeof( USHORT );
			NextOffset = (PUSHORT)((PCHAR)pbr + sizeof( IMAGE_BASE_RELOCATION ));
			VA = (ULONG_PTR)g_hEngineDLL + pbr->VirtualAddress;

			USHORT Offset;
			PUCHAR FixupVA;

			while ( SizeOfBlock-- ) {
				Offset = *NextOffset & (USHORT)0xfff;
				FixupVA = (PUCHAR)(VA + Offset);

				switch ( (*NextOffset) >> 12 ) {
					case IMAGE_REL_BASED_HIGHLOW:
						if((DWORD_PTR)EndOfCode > (DWORD_PTR)FixupVA)
						{
							g_vecReloc.push_back((PDWORD_PTR)FixupVA);
						}

						break;
					default:
						break;
				}

				++NextOffset;
			}

			pbr = (PIMAGE_BASE_RELOCATION)NextOffset;
		}
	}

	return true;
}

void *find_push_str(const char *str)
{
	DWORD_PTR segment = psech[2].VirtualAddress + (DWORD_PTR)g_hEngineDLL;
	DWORD_PTR end_segment = segment + psech[2].Misc.VirtualSize;

	size_t length = strlen(str);

	for(size_t i= 0; i< g_vecReloc.size();i++)
	{
		PUCHAR reloc = (PUCHAR)g_vecReloc[i];
		reloc--;

		if(reloc[0] != 0x68)
			continue;

		DWORD_PTR op = *(DWORD_PTR*)&reloc[1];

		if(!(op > segment && op < end_segment))
			continue;

		if(!strncmp((char *)op, str, length))
		{
			return (void *)reloc;
		}
	}

	return NULL;
}

void *find_any_str(const char *str)
{
	DWORD_PTR segment = psech[2].VirtualAddress + (DWORD_PTR)g_hEngineDLL;
	DWORD_PTR end_segment = segment + psech[2].Misc.VirtualSize;

	size_t length = strlen(str);

	for(size_t i= 0; i< g_vecReloc.size();i++)
	{
		PUCHAR reloc = (PUCHAR)g_vecReloc[i];

		DWORD_PTR op = *(DWORD_PTR*)reloc;

		if(!(op > segment && op < end_segment))
			continue;

		if(!strncmp((char *)op, str, length))
		{
			return (void *)reloc;
		}
	}

	return NULL;
}

//8B 04 8D 00 00 00 00 85 C0

bool parse_clc_funcs()
{
	fnParse pfnParse;
	void *range = find_push_str("SV_ReadClientMessage: badread\n");
	if(range == NULL)
		return false;

	unsigned char *ip = (unsigned char *)range;

	for(size_t i = 0; i < 64; i++)
	{
		ip--;

		if(!(ip[0] == 0x8B && ip[1] == 0x04 && ip[2] == 0x8D))
			continue;

		pfnParse = *(fnParse*)&ip[3];
		sv_clcfuncs = CONTAINING_RECORD(pfnParse, clc_func_t, pfnParse);

		LOG_MESSAGE(PLID, "sv_clcfuncs:%p", sv_clcfuncs);
		return true;
	}

	ip = (unsigned char *)range;
	for(size_t i = 0; i < 64; i++)
	{
		ip++;

		if(!(ip[0] == 0x8B && ip[1] == 0x04 && ip[2] == 0x8D))
			continue;

		pfnParse = *(fnParse*)&ip[3];
		sv_clcfuncs = CONTAINING_RECORD(pfnParse, clc_func_t, pfnParse);

		LOG_MESSAGE(PLID, "sv_clcfuncs:%p", sv_clcfuncs);
		return true;
	}

	return false;
}

bool parse_Netchan_OutOfBandPrint(void)
{
	void *range = find_push_str("\"%s<%i><%s><>\" connected, address \"%s\"\n");
	if(range == NULL)
		return false;

	unsigned char *reloc = (unsigned char *)range;
Do:
	reloc--;
	while(*reloc != 0x68)
		reloc--;

	if(*(reloc - 2) != 0x6a)
		goto Do;


	while(!(reloc[0] == 0x6A && reloc[1] == 0x01))
		reloc++;

	while(!(reloc[0] == 0xe8))
		reloc++;

	DWORD_PTR addr = (DWORD_PTR)&reloc[0] + *(int*)&reloc[1] + 0x5;
	Netchan_OutOfBandPrint = (fnNetchan_OutOfBandPrint)addr;

	return true;
}

bool Parse_SV_ConnectClient(void)
{
	unsigned char *reloc = (unsigned char *)find_push_str("Insufficient connection info");

	if(reloc == NULL)
		return false;

	do 
	{
		reloc--;
	} while (!(reloc[0] == 0x55 && reloc[1] == 0x8b && reloc[2] == 0xec));

	g_pfnSV_ConnectClient = (fnSV_ConnectClient)reloc;

	int i = 0;
	while(i < 128)
	{
		if(reloc[0] == 0xBE && (reloc-5)[0] == 0xB9)
		{
			net_from = *(netadr_t **)&reloc[1];
			break;
		}
		reloc++;
		i++;
	}

	return true;
}


bool parse_net_message()
{
	unsigned char *adr = (unsigned char *)find_any_str("net_message");
	if(adr == NULL)
		return false;

	if((adr- 0x6)[0] == 0xc7 && (adr- 0x6)[1] == 0x05)
	{
		net_message = *(sizebuf_t **)(adr-0x4);
		return true;
	}

	return false;
}


bool parse_msg_readcount()
{
	unsigned char *adr = (unsigned char *)find_push_str("SV_ParseVoiceData: invalid incoming packet.\n");
	if(adr == NULL)
		return false;

	unsigned char *calfunc;
	int i = 0;

	do
	{
		if(adr[0] == 0xe8)
		{
			calfunc = (adr + *(int *)&adr[1] + 0x5);
			break;
		}

		adr--;
		i++;
	}while(i < 128);

	if(calfunc[0] == 0xa1)
	{
		pmsg_readcount = *(int **)&calfunc[1];
		return true;
	}

	return false;
}

bool Parse_SV_DropClient()
{
	unsigned char *adr = (unsigned char *)find_push_str("Kicked and banned");
	if(adr == NULL)
		return false;

	while(!(adr[0] == 0xe8))
		adr++;

	SV_DropClient = (fnSV_DropClient)(adr + *(int*)&adr[1] + 0x5);
	return true;
}

bool Parse_SV_ClientPrintf()
{
	unsigned char *adr = (unsigned char *)find_push_str("You can't 'kick' because you are not a server operator\n");
	if(adr == NULL)
		return false;

	while(!(adr[0] == 0xe8))
		adr++;

	SV_ClientPrintf = (fnSV_ClientPrintf)(adr + *(int*)&adr[1] + 0x5);
	return true;
}


void (*SZ_Write) (sizebuf_t *buf, void *data, int length);
void *patch_Netchan_Process_SZ_Write;

bool Parse_Netchan_Process_SZ_Write()
{
	unsigned char *adr = (unsigned char *)find_push_str("Netchan_Process:  Couldn't allocate or find buffer %i\n");
	if(adr == NULL)
		return false;

	for(int i =0; i < 64 ;i++)
	{
		if(adr[0] == 0x50 && adr[1] == 0xe8)
			break;

		adr--;
	}

	patch_Netchan_Process_SZ_Write = &adr[1];
	SZ_Write = (void (*)(sizebuf_t *buf, void *data, int length))((unsigned char *)&adr[1] + *(int *)&adr[2] + 0x5);
	
	return true;
}

cmd_function_t **cmd_functions;

bool Parse_Cmd_Functions()
{
	unsigned char *adr = (unsigned char *)find_push_str("Cmd_AddCommand: %s already defined as a var\n");
	if(adr == NULL)
		return false;

	for(int i =0; i < 64 ;i++)
	{
		if(adr[0] == 0x8b && adr[1] == 0x35)
			break;

		adr++;
	}

	cmd_functions = *(cmd_function_t ***)&adr[2];
	return true;
}

client_t **phost_client;
bool Parse_HostClient()
{
	unsigned char *adr = (unsigned char *)find_push_str("Kick: \"%s<%i><%s><>\" was kicked by \"%s\"\n");
	if(adr == NULL)
		return false;

	for(int i =0; i < 64 ;i++)
	{
		if(adr[0] == 0x8b && adr[1] == 0x15)
			break;

		adr++;
	}

	phost_client = *(client_t ***)&adr[2];

	return true;
}

bool Parse_Netchan_Validate()
{
	DWORD_PTR EndOfCode = psech[0].Misc.VirtualSize + psech[0].VirtualAddress + (DWORD_PTR)g_hEngineDLL;
	ULONG Size = EndOfCode - (ULONG_PTR)g_hEngineDLL;
	unsigned char *adr = (unsigned char *)find_pattern((PVOID)g_hEngineDLL, 
		Size, "\x7C\x3C\x81\xFA\xA8\x61\x00\x00\x7F\x34\x8B\x0C\x07\x85\xC9\x7C\x2D\x81\xF9\x00\x08\x00\x00",
		"xxxxxxxxxxxxxxxxxxxxxxx");
	
	
	if(adr == NULL)
		return false;

	for(int i =0; i < 128 ;i++)
	{
		if(adr[0] == 0x55 && adr[1] == 0x8b && adr[2] == 0xec)
			break;

		adr--;
	}

	g_pfnNetchan_Validate = (fnNetchan_Validate)adr;
	return true;
}


bool Parse_NET_GetLong()
{
	DWORD_PTR EndOfCode = psech[0].Misc.VirtualSize + psech[0].VirtualAddress + (DWORD_PTR)g_hEngineDLL;
	ULONG Size = EndOfCode - (ULONG_PTR)g_hEngineDLL;
	unsigned char *adr = (unsigned char *)find_pattern((PVOID)g_hEngineDLL, 
		Size, "\x83\xE9\x09\x7F\x02\x33\xC9\xEB\x67\x55",
		"xxxxxxxxxx");
	
	if(adr == NULL)
		return false;

	g_pfnNET_GetLong = (fnNET_GetLong)adr;
	return true;
}
