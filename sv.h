#pragma once

#include <netadr.h>


typedef enum netsrc_s
{
	NS_CLIENT,
	NS_SERVER,
	NS_MULTICAST
} netsrc_t;

typedef struct client_s client_t;

//
// client to server
//
#define clc_bad			0
#define clc_nop			1
#define clc_move		2			// [usercmd_t]
#define clc_stringcmd	3		// [string] message
#define clc_delta		4       // [byte] request for delta compressed entity packet, 
								//  delta is from last incoming sequence [byte].
#define clc_resourcelist	5
#define clc_tmove		6
#define clc_fileconsistency	7
#define clc_voicedata	8       // Voicestream data from a client
#define clc_hltv		9
#define clc_cvarvalue	10
#define clc_cvarvalue2	11
#define CLC_LASTMSG		11

typedef struct clc_func_s
{
	// Opcode
	unsigned char opcode;  
	// Display Name
	char *pszname;         
	// Parse function
	void ( *pfnParse )(client_t *cl);
} clc_func_t;

typedef void ( *fnParse )(client_t *cl);

typedef void (*fnNetchan_OutOfBandPrint) (netsrc_t sock, netadr_t adr, char *format, ...);
typedef void (*fnSV_ConnectClient)(void);

#define S2C_CONNREJECT '9' 
#define MAX_INFO_STRING 256

#define FSB_ALLOWOVERFLOW	(1<<0)		// if false, do a Sys_Error
#define FSB_OVERFLOWED		(1<<1)		// set to true if the buffer size failed
typedef struct sizebuf_s
{
	char	*buffername;
	int		flags;
	byte	*data;
	int		maxsize;
	int		cursize;
} sizebuf_t;

typedef void (*fnSV_DropClient) (client_t *cl, qboolean crash, char *fmt, ... );
typedef void (*fnSV_ClientPrintf) (char *fmt, ...);
typedef qboolean (*fnNetchan_Validate)( struct netchan_s *chan, qboolean *frag_message, unsigned int *fragid, int *frag_offset, int *frag_length );
typedef qboolean (*fnNET_GetLong)( byte *pData, int size, int *outSize );
typedef void (*xcommand_t) (void);

typedef enum
{
	src_client,		// came in over a net connection as a clc_stringcmd
					// host_client will be valid during this state.
	src_command		// from the command buffer
} cmd_source_t;

typedef struct cmd_function_s
{
	struct cmd_function_s	*next;
	char					*name;
	xcommand_t				function;
	int					flags;
} cmd_function_t;


#define FCMD_CLIENTDLL		(1<<0)  // defined by the client dll
#define FCMD_EXTDLL			(1<<1)	// defined by external DLL
#define FCMD_WRAPPER		(1<<2)	// defined by system wrapper

typedef void (*fnSV_BeginFileDownload_f)( void );


#ifndef MAX_OSPATH
#define MAX_OSPATH MAX_PATH
#endif

#define MAX_STREAMS 2

#define MAX_RATE 100000
#define MIN_RATE 1000

#define DEFAULT_RATE (9999.0)

#define NET_MAX_PAYLOAD 3990
#define NET_MAX_HEADER 27

#define MAX_FLOWS 2

#define FLOW_OUTGOING 0
#define FLOW_INCOMING 1

typedef struct
{
	int size;
	double time;
}
flowstats_t;

#define MAX_LATENT 32

typedef struct
{
	flowstats_t stats[MAX_LATENT];

	int current;
	double nextcompute;
	float kbytespersec;
	float avgkbytespersec;
}
flow_t;

#define FRAGMENT_SIZE 1400

#define FRAG_NORMAL_STREAM 0
#define FRAG_FILE_STREAM 1

typedef struct fragbuf_s
{
	struct fragbuf_s *next;
	int bufferid;
	sizebuf_t frag_message;
	byte frag_message_buf[FRAGMENT_SIZE];
	qboolean isfile;
	qboolean isbuffer;
	char filename[MAX_OSPATH];
	int foffset;
	int size;
}
fragbuf_t;

typedef struct fragbufwaiting_s
{
	struct fragbufwaiting_s *next;
	int fragbufcount;
	fragbuf_t *fragbufs;
}
fragbufwaiting_t;

typedef struct netchan_s
{
	netsrc_t sock;
	netadr_t remote_address;

	int player_slot;
	float last_received;
	float connect_time;

	double rate;
	double cleartime;

	int incoming_sequence;
	int incoming_acknowledged;
	int incoming_reliable_acknowledged;
	int incoming_reliable_sequence;

	int outgoing_sequence;
	int reliable_sequence;
	int last_reliable_sequence;

	struct client_s *connection_status;
	int (*pfnNetchan_Blocksize)(struct client_s *client);

	sizebuf_t message;
	byte message_buf[NET_MAX_PAYLOAD];

	int reliable_length;
	byte reliable_buf[NET_MAX_PAYLOAD];

	fragbufwaiting_t *waitlist[MAX_STREAMS];
	qboolean reliable_fragment[MAX_STREAMS];
	unsigned int reliable_fragid[MAX_STREAMS];
	fragbuf_t *fragbufs[MAX_STREAMS];
	int fragbufcount[MAX_STREAMS];
	short frag_startpos[MAX_STREAMS];
	short frag_length[MAX_STREAMS];
	fragbuf_t *incomingbufs[MAX_STREAMS];
	qboolean incomingready[MAX_STREAMS];
	char incomingfilename[MAX_OSPATH];
	byte *tempbuffer;
	int tempbuffersize;
	flow_t flow[MAX_FLOWS];

	qboolean compression;
}
netchan_t;